todo\+: write more

The pressio4py Galerkin ROMs are designed such that using them involves three main steps\+:\hypertarget{md_pages_components_rom_galerkin_autotoc_md62}{}\doxysection{1. Create}\label{md_pages_components_rom_galerkin_autotoc_md62}
You create an instance of a \char`\"{}\+Galerkin problem\char`\"{}, e.\+g.\+: ~\newline



\begin{DoxyCode}{0}
\DoxyCodeLine{problem = pressio4py.rom.galerkin.DefaultExplicitProblem(args)}

\end{DoxyCode}


We currently support three variants\+:


\begin{DoxyItemize}
\item Default\+: \href{md_pages_components_rom_galerkin_default.html}{\texttt{ link}}
\item Hyper-\/reduced\+: \href{md_pages_components_rom_galerkin_hypred.html}{\texttt{ link}}
\item Masked\+: \href{md_pages_components_rom_galerkin_masked.html}{\texttt{ link}}
\end{DoxyItemize}

The {\ttfamily problem} object behaves like a stepper. Therefore, you can use the problem like you would with any other stepper object (more on this below).\hypertarget{md_pages_components_rom_galerkin_autotoc_md63}{}\doxysubsection{Explicit Problem}\label{md_pages_components_rom_galerkin_autotoc_md63}
The problem meets the following API\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }GalerkinProblem}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{def }\_\_call\_\_(state, time, time\_step\_size, step\_count);}
\DoxyCodeLine{}
\DoxyCodeLine{  def fomStateReconstructor();}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_pages_components_rom_galerkin_autotoc_md64}{}\doxysubsection{Implicit Problem}\label{md_pages_components_rom_galerkin_autotoc_md64}
The problem meets the following API\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }GalerkinProblem}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{def }\_\_call\_\_(state, time, time\_step\_size, step\_count, solver);}
\DoxyCodeLine{}
\DoxyCodeLine{  def createResidual()}
\DoxyCodeLine{    \textcolor{keywordflow}{return} \textcolor{comment}{\# a residual instance}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{def }createJacobian()}
\DoxyCodeLine{    return \textcolor{comment}{\# a Jacobian instance}}
\DoxyCodeLine{}
\DoxyCodeLine{  def residual(state, R)}
\DoxyCodeLine{    \textcolor{comment}{\# evaluates the residual for the given state}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{def }jacobian(state, J)}
\DoxyCodeLine{    \textcolor{comment}{\# evaluates the Jacobian for the given state}}
\DoxyCodeLine{}
\DoxyCodeLine{  def fomStateReconstructor();}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_pages_components_rom_galerkin_autotoc_md65}{}\doxysection{2. Solve in time}\label{md_pages_components_rom_galerkin_autotoc_md65}
What does a stepper have to do with a Galerkin ROM problme? The answer is that practically speaking, at the lowest-\/level, a Galerkin problem can be reduced to simply a \char`\"{}custom\char`\"{} stepper to advance in time. This is how pressio4py implements this and the reason why a Galerkin problem contains a stepper object inside\+: when you create the problem, pressio creates the appropriate custom stepper object that you can use. You don\textquotesingle{}t need to know how this is done, or rely on the details, because these are problem-\/ and implementation-\/dependent, and we reserve the right to change this in the future.


\begin{DoxyCode}{0}
\DoxyCodeLine{problem = ...}
\DoxyCodeLine{pressio4py.ode.advance\_n\_steps\_and\_observe(problem, ...)}

\end{DoxyCode}
 