A key assumption of projection-\/based R\+O\+Ms relies on approximating a full-\/order model (F\+OM) state, $y_{fom}$, as\+: \[ y_{fom} = g(y_{rom}) \]

where $y_{rom}$ is the reduced state, also called generalized coordinates, and $g$ is the mapping between the two. If $g$ is linear, then we can write\+: \[ y_{fom} = \phi y_{rom} \] where $\phi$ is a matrix (for the time being assumed constant). The Jacobian of the mapping is\+: \[ \frac{d y_{fom}}{d y_{rom}} = \phi. \]

A linear decoder in pressio4py represents this linear mapping.

Note that the above expressions are abtract. Indeed, we have not yet specified what kind of data structure is used for $y_{fom}$. pressio4py supports the following scenarios\+:
\begin{DoxyItemize}
\item the F\+OM state is represented as an array, i.\+e. $y_{fom} \in R^N$, where $N$ is the {\bfseries{total number of degrees of freedom}}. In this case, even if the application involves multiple fields (e.\+g., density, chemical species, etc), one stores all the spatial degrees of freedom this is typically used when the application needs to do implicit time-\/integration such that a large system needed to be solve.\+d
\item the F\+OM state is represented as rank-\/2 tensor, i.\+e. $y_{fom} \in R^N$
\end{DoxyItemize}\hypertarget{md_pages_tutorials_tutorial1_autotoc_md62}{}\doxysection{Rank-\/1 state}\label{md_pages_tutorials_tutorial1_autotoc_md62}
The full tutorial can be found \href{https://github.com/Pressio/pressio4py/blob/master/tutorials/tut_linear_decoder/main.py}{\texttt{ here}}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{from} pressio4py \textcolor{keyword}{import} rom \textcolor{keyword}{as} rom}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} \_\_name\_\_ == \textcolor{stringliteral}{"{}\_\_main\_\_"{}}:}
\DoxyCodeLine{  \textcolor{comment}{\# create the matrix}}
\DoxyCodeLine{  \textcolor{comment}{\# attention: we declare phi to be column-\/major for these reasons:}}
\DoxyCodeLine{  \textcolor{comment}{\#}}
\DoxyCodeLine{  \textcolor{comment}{\# 1. pressio4py uses blas (wherever possible) to operate on numpy arrays,}}
\DoxyCodeLine{  \textcolor{comment}{\#    so a column-\/major layout implies seamless compatiblity with blas}}
\DoxyCodeLine{  \textcolor{comment}{\#}}
\DoxyCodeLine{  \textcolor{comment}{\# 2. when using column-\/major layout, pressio4py references the}}
\DoxyCodeLine{  \textcolor{comment}{\#    matrix phi without doing a deep copy, which saves memory}}
\DoxyCodeLine{  \textcolor{comment}{\#    since a single jacobian matrix is alive.}}
\DoxyCodeLine{  \textcolor{comment}{\#}}
\DoxyCodeLine{  phi = np.ones((10,3), order=\textcolor{stringliteral}{'F'})}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{\# to create the linear decoder, one can simply do}}
\DoxyCodeLine{  linearDecoder = rom.Decoder(phi)}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{\# linearDecoder exposes a method to evaluate the mapping}}
\DoxyCodeLine{  fomState, romState = np.zeros(10), np.ones(3)}
\DoxyCodeLine{  linearDecoder.applyMapping(romState, fomState)}
\DoxyCodeLine{  print(y)}
\end{DoxyCode}




\begin{DoxyParagraph}{Where can you use the linear decoder?}
A linear decoder can be used for both Galerkin and L\+S\+PG as shown in subsequent tutorials and in the demos. 
\end{DoxyParagraph}
