<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>1D adv-diff: Comparing Masked POD Galerkin against masked POD LSPG | Pressio4Py</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Pressio4Py</a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="md_pages_prepare_your_app.html">How to interface your app</a></li>
            <li>
              <a href=>Tutorials</a>
              <ol>
                <li><a href="md_pages_tutorials_tutorial1.html">Linear Decoder</a></li>
                <li><a href="md_pages_tutorials_tutorial2.html">Custom Decoder</a></li>
                <li><a href="md_pages_tutorials_tutorial3.html">Default Galerkin explicit</a></li>
              </ol>
            </li>
            <li>
              <a href=>Demos</a>
              <ol>
                <li><a href="md_pages_demos_demo1.html">1D adv-diff: Galerkin with POD modes</a></li>
                <li><a href="md_pages_demos_demo2.html">1D adv-diff: LSPG with POD modes</a></li>
                <li><a href="md_pages_demos_demo3.html">1D adv-diff: LSPG with nonlinear manifold (kPCA) </a></li>
                <li><a href="md_pages_demos_demo4.html">1D adv-diff: POD Galerkin with collocation mask</a></li>
                <li><a href="md_pages_demos_demo5.html">1D adv-diff: Collocation-based Masked POD Galerkin vs LSPG</a></li>
              </ol>
            </li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="4">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          1D adv-diff: Comparing Masked POD Galerkin against masked POD LSPG
        </h1>
<aside class="m-block m-info"><p>This page describes a demo for a reproductive &quot;masked&quot; Galerkin and LSPG ROMs applied to a 1D advection-diffusion problem using POD modes as basis. The full demo script is <a href="https://github.com/Pressio/pressio4py/blob/master/demos/unsteady_masked_galerkin_vs_lspg_advdiff1d_pod/main.py">here.</a></p></aside><aside class="m-note m-default"><h4>We are currently working on this page, it will be updated with more explanations.</h4></aside><section id="autotoc_md33"><h2><a href="#autotoc_md33">Overview</a></h2><p>This is a follow up to the previous demo <a href="./md_pages_demos_demo4.html">here</a> We compare here maskdd Galerkin and masked LSPG.</p></section><section id="autotoc_md34"><h2><a href="#autotoc_md34">Main function</a></h2><p>The main function of the demo is the following:</p><pre class="m-code"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
  <span class="n">logger</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">logger</span><span class="o">.</span><span class="n">logto</span><span class="o">.</span><span class="n">terminal</span><span class="p">,</span> <span class="s2">&quot;null&quot;</span><span class="p">)</span>
  <span class="n">logger</span><span class="o">.</span><span class="n">setVerbosity</span><span class="p">([</span><span class="n">logger</span><span class="o">.</span><span class="n">loglevel</span><span class="o">.</span><span class="n">info</span><span class="p">])</span>

  <span class="c1"># total number of grid points</span>
  <span class="n">meshSize</span> <span class="o">=</span> <span class="mi">200</span>

  <span class="c1"># create fom object</span>
  <span class="n">fomObj</span> <span class="o">=</span> <span class="n">AdvDiff1d</span><span class="p">(</span><span class="n">nGrid</span><span class="o">=</span><span class="n">meshSize</span><span class="p">,</span> <span class="n">adv_coef</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

  <span class="c1"># the final time to integrate to</span>
  <span class="n">finalTime</span> <span class="o">=</span> <span class="o">.</span><span class="mi">05</span>

  <span class="c1">#--- 1. FOM ---#</span>
  <span class="n">fomTimeStepSize</span>  <span class="o">=</span> <span class="mf">1e-5</span>
  <span class="n">fomNumberOfSteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">finalTime</span><span class="o">/</span><span class="n">fomTimeStepSize</span><span class="p">)</span>
  <span class="n">sampleEvery</span>      <span class="o">=</span> <span class="mi">100</span>
  <span class="p">[</span><span class="n">fomFinalState</span><span class="p">,</span> <span class="n">snapshots</span><span class="p">]</span> <span class="o">=</span> <span class="n">doFom</span><span class="p">(</span><span class="n">fomObj</span><span class="p">,</span> <span class="n">fomTimeStepSize</span><span class="p">,</span> <span class="n">fomNumberOfSteps</span><span class="p">,</span> <span class="n">sampleEvery</span><span class="p">)</span>

  <span class="c1">#--- 2. POD ---#</span>
  <span class="n">modes</span> <span class="o">=</span> <span class="n">computePodModes</span><span class="p">(</span><span class="n">snapshots</span><span class="p">)</span>

  <span class="c1">#--- 3. MASKED GALERKIN and LSPG ROM ---#</span>
  <span class="c1"># a masked problem is supposed to make it easier to emulate the</span>
  <span class="c1"># effect of hyper-reduction. To create a mask ROM problem,</span>
  <span class="c1"># we need to select and provide to pressio a set of indices</span>
  <span class="c1"># identifying a subset of the grid points in the full mesh.</span>
  <span class="c1"># This is a simple way to mimic hyper-reduction</span>
  <span class="c1"># without changing the FOM problem. In fact, the fom still</span>
  <span class="c1"># computes the full operators but we have an additional step</span>
  <span class="c1"># to &quot;mask&quot; the operators to compute the sample mesh version.</span>
  <span class="c1"># In this test, the meshSize = 200. Our sample mesh includes</span>
  <span class="c1"># the two end points since those contain the boundary conditions,</span>
  <span class="c1"># and 20 randomly selected grid points inside the domain.</span>
  <span class="c1"># So effectively we use 1/10 of the full mesh.</span>
  <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">22123</span><span class="p">)</span>
  <span class="n">sampleMeshSize</span> <span class="o">=</span> <span class="mi">20</span>
  <span class="n">sampleMeshIndices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">199</span><span class="p">),</span> <span class="n">sampleMeshSize</span><span class="p">)</span>
  <span class="n">sampleMeshIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sampleMeshIndices</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">199</span><span class="p">])</span>
  <span class="c1"># sort for convenience, not necessarily needed</span>
  <span class="n">sampleMeshIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sampleMeshIndices</span><span class="p">)</span>

  <span class="n">romSize</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># number of modes to use</span>
  <span class="n">romTimeStepSize</span>  <span class="o">=</span> <span class="mf">1e-4</span>
  <span class="n">romNumberOfSteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">finalTime</span><span class="o">/</span><span class="n">romTimeStepSize</span><span class="p">)</span>

  <span class="c1"># run the masked galerkin problem</span>
  <span class="p">[</span><span class="n">approximatedStateGal</span><span class="p">,</span> <span class="n">romGal</span><span class="p">]</span> <span class="o">=</span> <span class="n">runMaskedGalerkin</span><span class="p">(</span><span class="n">fomObj</span><span class="p">,</span> <span class="n">romTimeStepSize</span><span class="p">,</span>
                                                     <span class="n">romNumberOfSteps</span><span class="p">,</span>
                                                     <span class="n">modes</span><span class="p">[:,:</span><span class="n">romSize</span><span class="p">],</span>
                                                     <span class="n">sampleMeshIndices</span><span class="p">)</span>
  <span class="c1"># run the masked galerkin problem</span>
  <span class="p">[</span><span class="n">approximatedStateLspg</span><span class="p">,</span> <span class="n">romLspg</span><span class="p">]</span> <span class="o">=</span> <span class="n">runMaskedLspg</span><span class="p">(</span><span class="n">fomObj</span><span class="p">,</span> <span class="n">romTimeStepSize</span><span class="p">,</span>
                                                   <span class="n">romNumberOfSteps</span><span class="p">,</span>
                                                   <span class="n">modes</span><span class="p">[:,:</span><span class="n">romSize</span><span class="p">],</span>
                                                   <span class="n">sampleMeshIndices</span><span class="p">)</span>

  <span class="c1"># compute l2-error between fom and approximate state</span>
  <span class="n">fomNorm</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fomFinalState</span><span class="p">)</span>
  <span class="n">err1</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fomFinalState</span><span class="o">-</span><span class="n">approximatedStateGal</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Galerkin: final state relative l2 error: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err1</span><span class="o">/</span><span class="n">fomNorm</span><span class="p">))</span>
  <span class="n">err2</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fomFinalState</span><span class="o">-</span><span class="n">approximatedStateLspg</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LSPG: final state relative l2 error: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err2</span><span class="o">/</span><span class="n">fomNorm</span><span class="p">))</span></pre><section id="autotoc_md35"><h3><a href="#autotoc_md35">1. Run FOM and collect snapshots</a></h3><pre class="m-code"><span class="k">def</span> <span class="nf">doFom</span><span class="p">(</span><span class="n">fom</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">,</span> <span class="n">saveFreq</span><span class="p">):</span>
  <span class="n">u</span> <span class="o">=</span> <span class="n">fom</span><span class="o">.</span><span class="n">u0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="n">U</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">fom</span><span class="o">.</span><span class="n">createVelocity</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nsteps</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># query rhs of discretized system</span>
    <span class="n">fom</span><span class="o">.</span><span class="n">velocity</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="c1"># simple Euler forward</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">saveFreq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">U</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
  <span class="n">Usolns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">Usolns</span><span class="o">.</span><span class="n">T</span><span class="p">]</span></pre></section><section id="autotoc_md36"><h3><a href="#autotoc_md36">2. Compute POD modes</a></h3><pre class="m-code"><span class="k">def</span> <span class="nf">computePodModes</span><span class="p">(</span><span class="n">snapshots</span><span class="p">):</span>
  <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SVD on matrix: &quot;</span><span class="p">,</span> <span class="n">snapshots</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">VT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">snapshots</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">U</span></pre></section><section id="autotoc_md37"><h3><a href="#autotoc_md37">3. Create the sampling indices</a></h3><pre class="m-code"><span class="c1"># a masked problem is supposed to make it easier to emulate the</span>
<span class="c1"># effect of hyper-reduction. To create a mask ROM problem,</span>
<span class="c1"># we need to select and provide to pressio a set of indices</span>
<span class="c1"># identifying a subset of the grid points in the full mesh.</span>
<span class="c1"># This is a simple way to mimic hyper-reduction</span>
<span class="c1"># without changing the FOM problem. In fact, the fom still</span>
<span class="c1"># computes the full operators but we have an additional step</span>
<span class="c1"># to &quot;mask&quot; the operators to compute the sample mesh version.</span>
<span class="c1"># In this test, the meshSize = 200. Our sample mesh includes</span>
<span class="c1"># the two end points since those contain the boundary conditions,</span>
<span class="c1"># and 20 randomly selected grid points inside the domain.</span>
<span class="c1"># So effectively we use 1/10 of the full mesh.</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">22123</span><span class="p">)</span>
<span class="n">sampleMeshSize</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">sampleMeshIndices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">199</span><span class="p">),</span> <span class="n">sampleMeshSize</span><span class="p">)</span>
<span class="n">sampleMeshIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sampleMeshIndices</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">199</span><span class="p">])</span>
<span class="c1"># sort for convenience, not necessarily needed</span>
<span class="n">sampleMeshIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sampleMeshIndices</span><span class="p">)</span>

<span class="n">romSize</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># number of modes to use</span>
<span class="n">romTimeStepSize</span>  <span class="o">=</span> <span class="mf">1e-4</span>
<span class="n">romNumberOfSteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">finalTime</span><span class="o">/</span><span class="n">romTimeStepSize</span><span class="p">)</span></pre></section><section id="autotoc_md38"><h3><a href="#autotoc_md38">4. The masker class</a></h3><pre class="m-code"><span class="k">class</span> <span class="nc">MyMasker</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">rows_</span> <span class="o">=</span> <span class="n">indices</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sampleMeshSize_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">createApplyMaskResult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampleMeshSize_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sampleMeshSize_</span><span class="p">,</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

  <span class="k">def</span> <span class="nf">applyMask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">result</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">result</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows_</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></pre></section><section id="autotoc_md39"><h3><a href="#autotoc_md39">5. Masked Galerkin ROM</a></h3><pre class="m-code"><span class="k">def</span> <span class="nf">runMaskedGalerkin</span><span class="p">(</span><span class="n">fomObj</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">sampleMeshIndices</span><span class="p">):</span>
  <span class="c1"># find out number of modes wanted</span>
  <span class="n">romSize</span> <span class="o">=</span> <span class="n">modes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

  <span class="c1"># fom reference state: here it is zero</span>
  <span class="n">fomReferenceState</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fomObj</span><span class="o">.</span><span class="n">nGrid</span><span class="p">)</span>

  <span class="c1"># create ROM state by projecting the fom initial condition</span>
  <span class="n">fomInitialState</span> <span class="o">=</span> <span class="n">fomObj</span><span class="o">.</span><span class="n">u0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="n">romState</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">modes</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">fomInitialState</span><span class="p">)</span>

  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  creating a masked Galerkin problem involves these steps:</span>
<span class="sd">  (1) creating the decoder on the FULL mesh</span>
<span class="sd">  (2) create a &quot;projector operator&quot; by filtering the rows</span>
<span class="sd">      of the POD modes only on the sample mesh (aka mask) indices.</span>
<span class="sd">      The projector is responsible to project the FOM velocity.</span>
<span class="sd">      Note that one can use other matrices for the projector</span>
<span class="sd">      but that will be shown in other demos.</span>
<span class="sd">  (3) create a masker object responsible to mask the FOM operators.</span>
<span class="sd">  (4) create the masked Galerkin problem</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="c1"># 1. create a linear decoder</span>
  <span class="n">linearDecoder</span> <span class="o">=</span> <span class="n">rom</span><span class="o">.</span><span class="n">Decoder</span><span class="p">(</span><span class="n">modes</span><span class="p">)</span>

  <span class="c1"># 2. create the projector</span>
  <span class="c1"># here, simply use &quot;collocation&quot; with the POD modes filtered on the &quot;sample mesh&quot;</span>
  <span class="n">modesOnSampleMesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">modes</span><span class="p">,</span> <span class="n">sampleMeshIndices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">projector</span> <span class="o">=</span> <span class="n">rom</span><span class="o">.</span><span class="n">galerkin</span><span class="o">.</span><span class="n">ArbitraryProjector</span><span class="p">(</span><span class="n">modesOnSampleMesh</span><span class="p">)</span>

  <span class="c1"># 3. create the masker object</span>
  <span class="n">masker</span> <span class="o">=</span> <span class="n">MyMasker</span><span class="p">(</span><span class="n">sampleMeshIndices</span><span class="p">)</span>

  <span class="c1"># 4. create the masked galerkin problem with Euler forward</span>
  <span class="n">problem</span> <span class="o">=</span> <span class="n">rom</span><span class="o">.</span><span class="n">galerkin</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">ProblemBackwardEuler</span><span class="p">(</span><span class="n">fomObj</span><span class="p">,</span> <span class="n">linearDecoder</span><span class="p">,</span>
                                                     <span class="n">romState</span><span class="p">,</span> <span class="n">fomReferenceState</span><span class="p">,</span>
                                                     <span class="n">masker</span><span class="p">,</span> <span class="n">projector</span><span class="p">)</span>

  <span class="c1"># linear and non linear solver</span>
  <span class="n">lsO</span> <span class="o">=</span> <span class="n">MyLinSolver</span><span class="p">()</span>
  <span class="n">nlsO</span> <span class="o">=</span> <span class="n">solvers</span><span class="o">.</span><span class="n">NewtonRaphson</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">romState</span><span class="p">,</span> <span class="n">lsO</span><span class="p">)</span>
  <span class="n">nlsO</span><span class="o">.</span><span class="n">setMaxIterations</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>

  <span class="c1"># solve the problem</span>
  <span class="n">rom</span><span class="o">.</span><span class="n">galerkin</span><span class="o">.</span><span class="n">advanceNSteps</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">romState</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">,</span> <span class="n">nlsO</span><span class="p">)</span>

  <span class="c1"># after we are done, use the reconstructor object to reconstruct the fom state</span>
  <span class="c1"># NOTE: even though the Galerkin problem was run on the &quot;masked mesh points&quot;,</span>
  <span class="c1"># this reconstruction uses the POD modes on the full mesh stored in the decoder</span>
  <span class="c1"># so we can effectively obtain an approximation of the full solution</span>
  <span class="n">fomRecon</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">fomStateReconstructor</span><span class="p">()</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">fomRecon</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">romState</span><span class="p">),</span> <span class="n">romState</span><span class="p">]</span></pre></section><section id="autotoc_md40"><h3><a href="#autotoc_md40">6. Masked LSPG ROM</a></h3><pre class="m-code"><span class="k">def</span> <span class="nf">runMaskedLspg</span><span class="p">(</span><span class="n">fomObj</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">sampleMeshIndices</span><span class="p">):</span>
  <span class="c1"># find out number of modes wanted</span>
  <span class="n">romSize</span> <span class="o">=</span> <span class="n">modes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

  <span class="c1"># fom reference state: here it is zero</span>
  <span class="n">fomReferenceState</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fomObj</span><span class="o">.</span><span class="n">nGrid</span><span class="p">)</span>

  <span class="c1"># create ROM state by projecting the fom initial condition</span>
  <span class="n">fomInitialState</span> <span class="o">=</span> <span class="n">fomObj</span><span class="o">.</span><span class="n">u0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="n">romState</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">modes</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">fomInitialState</span><span class="p">)</span>

  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  creating a masked LSPG problem involves these steps:</span>
<span class="sd">  (1) creating the decoder on the FULL mesh</span>
<span class="sd">  (2) create a masker object responsible to mask the FOM operators</span>
<span class="sd">  (3) create the masked LSPG problem</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="c1"># 1. create a linear decoder</span>
  <span class="n">linearDecoder</span> <span class="o">=</span> <span class="n">rom</span><span class="o">.</span><span class="n">Decoder</span><span class="p">(</span><span class="n">modes</span><span class="p">)</span>

  <span class="c1"># 2. create the masker object</span>
  <span class="n">masker</span> <span class="o">=</span> <span class="n">MyMasker</span><span class="p">(</span><span class="n">sampleMeshIndices</span><span class="p">)</span>

  <span class="c1"># 3. create the masked galerkin problem with Euler forward</span>
  <span class="n">problem</span> <span class="o">=</span> <span class="n">rom</span><span class="o">.</span><span class="n">lspg</span><span class="o">.</span><span class="n">unsteady</span><span class="o">.</span><span class="n">masked</span><span class="o">.</span><span class="n">ProblemEuler</span><span class="p">(</span><span class="n">fomObj</span><span class="p">,</span> <span class="n">linearDecoder</span><span class="p">,</span>
                                                  <span class="n">romState</span><span class="p">,</span> <span class="n">fomReferenceState</span><span class="p">,</span>
                                                  <span class="n">masker</span><span class="p">)</span>

  <span class="c1"># linear and non linear solver</span>
  <span class="n">lsO</span> <span class="o">=</span> <span class="n">MyLinSolver</span><span class="p">()</span>
  <span class="n">nlsO</span> <span class="o">=</span> <span class="n">solvers</span><span class="o">.</span><span class="n">GaussNewton</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">romState</span><span class="p">,</span> <span class="n">lsO</span><span class="p">)</span>
  <span class="n">nlsO</span><span class="o">.</span><span class="n">setMaxIterations</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

  <span class="c1"># solve the problem</span>
  <span class="n">rom</span><span class="o">.</span><span class="n">lspg</span><span class="o">.</span><span class="n">solveNSequentialMinimizations</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">romState</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">,</span> <span class="n">nlsO</span><span class="p">)</span>

  <span class="c1"># after we are done, use the reconstructor object to reconstruct the fom state</span>
  <span class="c1"># NOTE: even though the Galerkin problem was run on the &quot;masked mesh points&quot;,</span>
  <span class="c1"># this reconstruction uses the POD modes on the full mesh stored in the decoder</span>
  <span class="c1"># so we can effectively obtain an approximation of the full solution</span>
  <span class="n">fomRecon</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">fomStateReconstructor</span><span class="p">()</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">fomRecon</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">romState</span><span class="p">),</span> <span class="n">romState</span><span class="p">]</span></pre></section></section><section id="autotoc_md41"><h2><a href="#autotoc_md41">Results</a></h2><p>If everything works fine, the following plots shows the result. We first plot the result reconstructed <em>only on the sample mesh</em>. This can easily be done using the bases collocated on the sample mesh indices.</p><img class="m-image" src="demo5_f1.png" alt="Image" /><p>We then plot the fom solution reconstructed using the bases on the full mesh. Note that all we need to change is just using the full bases. We see that for this toy example, even with just 10% of the grid, LSPG with 5 modes accuractely reproduces the FOM solution. While for Galerkin the solution is less accurate.</p><img class="m-image" src="demo5_f2.png" alt="Image" /><aside class="m-block m-warning"><h3>Warning</h3><p>Note that using the mask to mimic hyper-reduction is only helpful to assess the accuracy but not the computational performance. This is because the &quot;masked&quot; problem still requires the FOM to compute the full kernels. Hyper-reduction becomes computationally very efficient if implemented without the mask, which we will show in subsequent demos.</p></aside></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Pressio4Py. Created with <a href="https://doxygen.org/">Doxygen</a> 1.8.20 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
